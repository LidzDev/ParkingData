"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEPS_GROUPS = void 0;
exports.findModuleDepsGroup = findModuleDepsGroup;
exports.getModuleHomepage = getModuleHomepage;
exports.getModuleInfo = void 0;
exports.getModuleVersion = getModuleVersion;
exports.loadGlobalPackages = loadGlobalPackages;
exports.loadPackageJson = loadPackageJson;
exports.setModuleVersion = setModuleVersion;

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var _path = require("path");

var _fs = require("fs");

var _libnpmconfig = _interopRequireDefault(require("libnpmconfig"));

var _pacote = _interopRequireDefault(require("pacote"));

var _shelljs = _interopRequireDefault(require("shelljs"));

const DEPS_GROUPS = [{
  name: 'global',
  field: 'dependencies',
  flag: 'g',
  ncuValue: 'prod'
}, {
  name: 'production',
  field: 'dependencies',
  flag: 'p',
  ncuValue: 'prod'
}, {
  name: 'optional',
  field: 'optionalDependencies',
  flag: 'o',
  ncuValue: 'optional'
}, {
  name: 'development',
  field: 'devDependencies',
  flag: 'd',
  ncuValue: 'dev'
}, {
  name: 'peer',
  field: 'peerDependencies',
  flag: 'r',
  ncuValue: 'peer'
}, {
  name: 'bundled',
  field: 'bundledDependencies',
  altField: 'bundleDependencies',
  flag: 'b',
  ncuValue: 'bundle'
}];
exports.DEPS_GROUPS = DEPS_GROUPS;
const getNpmConfig = (0, _memoize2.default)(() => {
  const config = {};

  _libnpmconfig.default.read().forEach((value, key) => {
    if (typeof value === 'string') {
      // Replacing env ${VARS} in strings with the `process.env` values
      config[key] = value.replace(/\$\{(.+?)\}/gu, (_, envVar) => process.env[envVar]);
    } else {
      config[key] = value;
    }
  });

  return config;
});

function loadGlobalPackages() {
  const res = _shelljs.default.exec('npm ls -g --depth 0 --json', {
    silent: true
  });

  if (res.code !== 0) {
    throw new Error(`Could not determine global packages: ${res.stderr}`);
  }

  try {
    const {
      dependencies
    } = JSON.parse(res);
    const content = {
      dependencies
    };

    for (const [pkg, {
      version
    }] of Object.entries(dependencies)) {
      content.dependencies[pkg] = version;
    }

    return {
      content
    };
  } catch (err) {
    console.error(`Error parsing global packages: ${err.message}`);
    process.exit(1);
  }
}

function loadPackageJson() {
  const packageFile = (0, _path.resolve)('./package.json');
  let packageJson;
  let packageSource;

  try {
    packageSource = (0, _fs.readFileSync)(packageFile, 'utf-8');
    packageJson = JSON.parse(packageSource);
  } catch (err) {
    console.error(`Error loading package.json: ${err.message}`);
    process.exit(1);
  }

  return {
    path: packageFile,
    content: packageJson,
    source: packageSource
  };
}

function findModuleDepsGroup(moduleName, packageJson) {
  for (const {
    field,
    altField
  } of DEPS_GROUPS) {
    let modules = packageJson[field];

    if (!modules && altField) {
      modules = packageJson[altField];
    }

    if (modules && modules[moduleName]) {
      return modules;
    }
  }

  return null;
}

function getModuleVersion(moduleName, packageJson) {
  const depsGroup = findModuleDepsGroup(moduleName, packageJson);
  return depsGroup ? depsGroup[moduleName] : null;
}

function setModuleVersion(moduleName, newVersion, packageJson) {
  const depsGroup = findModuleDepsGroup(moduleName, packageJson);

  if (depsGroup) {
    depsGroup[moduleName] = newVersion;
    return true;
  } else {
    return false;
  }
}

function getModuleHomepage(packageJson) {
  return packageJson.homepage || packageJson.url || null;
}

const getModuleInfo = (0, _memoize2.default)(async moduleName => _pacote.default.manifest(moduleName, { ...getNpmConfig(),
  fullMetadata: true
}));
exports.getModuleInfo = getModuleInfo;